\documentclass[11pt, oneside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
    \geometry{
     a4paper,
     top=20mm,
     }
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{underscore}
\usepackage{caption}
\usepackage{algorithmic}
\usepackage{enumitem}	
\usepackage{verbatim}
%\usepackage{tikzpicture}				% package for drawing node diagrams for search derivations
\def\infinity{\rotatebox{90}{8}}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}
\setlength{\parskip}{1em}
\setlength{\parindent}{4em}
\usepackage{graphicx}				% Use pdf, png, jpg, or epsÂ§ with pdflatex; use eps in DVI mode
								% TeX will automatically convert eps --> pdf in pdflatex		
\usepackage{amssymb}

\newenvironment{cmr}{\fontfamily{cmr}\selectfont}{\par}

\setlength{\parskip}{1em}
\setlength{\parindent}{4em}

\title{\vspace{40mm}CPSC 433 --- Assignment I}
\author{
	Daniel Gillson\\
	David Keizer\\
	Ethan Higgs\\
	Zheng Liang\\
	Zibin Mei}
\date{October 20\textsuperscript{th} 2017}

\newpage
\begin{document}
\maketitle
\break

\centerline{{\Large Search Paradigm I --- Set-Based Search}}

\noindent {\\ \large \textbf{Solution Overview}}\\\\
\begin{cmr}
\indent Our approach to solving the problem within the context of set-based search will rely mainly on the use of a genetic algorithm.
We will obtain an initial, randomly generated population for our GA via an Or-tree-based Search that will provide candidate solutions to the problem's
hard constraints. In this first stage of our solution, we ignore the problem's soft constraints, thereby re-formulating it as a constraint satisfaction problem (CSP).

\indent Once we have obtained an initial population of some size, pop_init, we will consider its individuals to be facts in a Set-based Search.
We will also define a constant, pop_max, as an upper bound on the size of any later generation.
The set-based search will use our genetic algorithm's crossover/mutation function, and a reduce function as its extension rules.
f\textsubscript{Wert} will be used to decide which extension rule to apply.
When the population has exceeded pop_max, f\textsubscript{Wert} will indicate that a reduction is to take place.
f\textsubscript{Select} will be used to determine which two facts to use as parents when applying the crossover/mutation extension rule.
The start state will be our initial set of randomly generated facts and our end condition will be a predetermined number of generations or a predetermined time limit, whichever comes first.

\indent In our GA, we will use \textbf{Eval} to measure how the well each fact meets soft constraints, \textbf{Constr} and \textbf{Constr\textsuperscript{*}}to check hard constraints, and roulette-wheel selection as a selection method for crossover/mutation.
\textbf{Constr\textsuperscript{*}} is a variant of \textbf{Constr} used to evaluate the constraint-compliance of partial solutions, which we assume can be derived from the provided \textbf{Constr} function.
\end{cmr}

\noindent {\large \textbf{Or-tree-based Search Model}}

\noindent We define Prob as a vector of length $\vert$Courses + Labs$\vert$, whose elements consist of the indices of slots from Slots, or the unassigned symbol, \$. The vector's ordering will preserve the original ordering of Courses + Labs. Therefore, a Prob vector can be read sequentially as: Course/Lab at position $i$, having value $j$, has been assigned time slot $s_j$, where $s_j$ is the member $s$ of the set Slots at the $j$\textsuperscript{th} index of that set. As such, our definition of Prob is equivalent with the notion of a partial assignment, \textit{partassign}.

\noindent Before formally defining Prob, we define $D_i$, the domain of any element in a problem instance, pr, to be the set: \{0, $\dots$, $j$\} where $j+1$ = $\vert$Slots$\vert$.

\noindent \centerline{Prob =  $\langle C_1 \text{slot}, \dots, C_n \text{slot}, \dots, L_{11} \text{slot}, \dots, L_{1{k_1}} \text{slot}, \dots, L_{n1} \text{slot}, \dots, L_{n{k_n}} \text{slot}\rangle$}\\
\centerline{such that $C_i \text{slot}$, $L_{i{k_i}} \text{slot} \in D_i \cup \{\$\}$}

\noindent Which can be abstracted into the form:

\noindent \centerline{Prob = $\langle X_1, \dots, X_n\rangle$ such that $X_i \in D_i \cup \{\$\}$}

\noindent We define our alternatives relation, Altern, as follows:

\noindent \centerline{Altern = $\{((X_1, \dots, X_i, \dots, X_n), (X_1, \dots, d_{i1}, \dots, X_{in}), \dots, (X_1, \dots, d_{i\ell}, \dots, X_n))$ $\vert$ $X_i$ = $\$$,}\\
\centerline{$1 \le i \le n$, $\vert D_i \vert = \ell$, $D_i = \{d_i, \dots, d_{i\ell}\}\}$}

\noindent We define the notion, ``pr is solved" as follows:

\noindent \centerline{pr = $(X_1, \dots, X_n)$ and $\forall i$ such that $1 \le i \le n$, $X_i$ $\neq$ $\$$, and pr is not unsolvable.}

\noindent We define the notion, ``pr is unsolvable" as follows:

\noindent \centerline{pr = $(X_1, \dots, X_n)$ and there is a constraint $C_i = R_i(X_1, \dots, X_k)$}\\
\centerline{such that $\exists X_{ij}$ $\in$ pr with a value unequal to $\$$ and $(X_1, \dots, X_k)$ do not satisfy $R_i$.}

\noindent Since we have access to \textbf{Constr\textsuperscript{*}}, derived from the provided function, \textbf{Constr}, we can allow \textbf{Constr\textsuperscript{*}} to perform the work of assessing whether any particular problem instance, pr, is compliant with the problem's hard constraints.

\noindent {\large \textbf{Or-tree-based Search Process}}

\begin{cmr}
\noindent Initial Search Control:
\begin{comment}
\noindent Our O\textsubscript{Tree} will obviously begin with a single node, (pr, ?). Its expansion will be governed by the recursive relation, Erw\textsubscript{$\lor$}.
After each application of Altern, the search control will perform a constraint analysis on each new successor node of O\textsubscript{Tree} using \textbf{Constr\textsuperscript{*}}.
\end{comment}

\noindent This is the search control for the generation of the initial population for the set-based search.

\noindent In order to decide which leaf to operate on, the search control first looks for leaf nodes where the problem is solved. If there are multiple of these leaf nodes, then one is chosen at random. The sol-entry of the selected node is then changed to yes.
If no such leaf nodes exist, then the search control considers any leaf nodes where the problem is unsolvable. Once again if there are multiple of these nodes, then one is selected at random. The sol-entry is then changed to no. If neither of these types of leaf nodes exist, then the search control selects the leaf which has the fewest unassigned courses/labs (\$'s), therefore the deepest leaf node in the tree. 
If there are multiple of these nodes, one will be chosen randomly and Altern will be applied to this node.

\end{cmr}
\begin{comment}
\noindent The search control will pick a random leaf from among the minimal f\textsubscript{leaf} values.
\end{comment}

\noindent In order to define f\textsubscript{leaf}, we must first define a function, sum\$: pr $\Rightarrow$ $\mathbb{Z}$. Which, given some pr, returns the number of \$ entries within it. 

\noindent We also want to define a function rand: pr $\Rightarrow$ $\mathbb{R}$. 

\noindent Here we have a set of problems P =  \{pr\textsubscript{1}, $\dots$, pr\textsubscript{$k$}\} $\vert$ sum$\$$(pr\textsubscript{$i$}) = sum$\$$(pr\textsubscript{$j$}), 1 $\geq$ i,j $\geq$ k

\noindent z is a random integer such that 1 $\geq$ z $\geq$ $\vert$ P $\vert$

    \[
        \text{rand} = \left\{\begin{array}{ll}
            0, & \text{: pr\textsubscript{$z$}}\\
            0.01, & \text{: pr\textsubscript{$i$} $\vert$ i $\neq$ z, 1 $\geq$ i $\geq$ $\vert$ P $\vert$}\\
            \end{array}\right\}
      \]

\noindent f\textsubscript{leaf}: pr\textsubscript{$i$} $\Rightarrow$ $\mathbb{R}$\\

\noindent Here  pr\textsubscript{$i$} = \{x\textsubscript{1}, $\dots$, x\textsubscript{$n$}\} and input is a \textit {partassign} = \{y\textsubscript{1}, $\dots$, y\textsubscript{$n$}\}, which is either the \textit partassign given to the search as the input or y\textsubscript{i} such that $\forall y\textsubscript{i}$ $\in$ input, y\textsubscript{i} = \$

    \[
        \text{f\textsubscript{leaf}} = \left\{\begin{array}{ll}
            -1, & \text{: (pr\textsubscript{$i$} is solved)}\\
            0, & \text{: (pr\textsubscript{$i$} is unsolvable)}\\
            \text{sum$\$$(pr\textsubscript{$i$})+ rand(pr\textsubscript{$i$})}, & \text{: $\forall x\textsubscript{i}$ = y\textsubscript{i} or x\textsubscript{i} = \$}\\
	\infty & \text{: else}
            \end{array}\right\}
      \]

\begin{comment}
\begin{cmr}
\noindent After f\textsubscript{leaf} values have been calculated for each node, if there is a solved node then the search is finished and the solved problem instance is returned as output.

\noindent Otherwise, all unsolvable nodes will be pruned, and a random integer, $r$, will be generated such that $1 \le r \le n$, where n is equal to the number of remaining new successor nodes generated by Altern.
Control will then select the $r$\textsuperscript{th} node and resume the expansion of O\textsubscript{Tree}.
\end{cmr}
\end{comment}
\begin{cmr}
\noindent Crossover Search Control:

\noindent This is the search control for the generation of the initial population for the set-based search.

\noindent This search control is similar to the initial search control. The only difference comes in when there are no solved or unsolvable leaf nodes. The leaf nodes with problems containing the fewest \$'s are considered however the tiebreaker is dependant one the parents used for the crossover. Leaf nodes with a problem, where each entry in the vector is either equal to the entry in the same position of either parent's vector or \$ are then chosen. These are chosen between randomly if multiple leaf nodes fitting this description exist. If none of these exist, then select randomly from the other leaf nodes with the fewest \$'s.

Here the two parents are relevant and will be denoted by Par\textsubscript{1} = \{par\textsubscript{1\textsubscript{1}}, $\dots$, par\textsubscript{1\textsubscript{$n$}}\} and Par\textsubscript{2} = \{par\textsubscript{1\textsubscript{2}}, $\dots$, par\textsubscript{2\textsubscript{$n$}}\}

    \[
        \text{f\textsubscript{leaf}} = \left\{\begin{array}{ll}
            -1, & \text{: (pr\textsubscript{$i$} is solved)}\\
            0, & \text{: (pr\textsubscript{$i$} is unsolvable)}\\
            \text{sum$\$$(pr\textsubscript{$i$})+ rand(pr\textsubscript{$i$})}, & \text{: $\forall x\textsubscript{i}$ = y\textsubscript{i} and (x\textsubscript{i} = par\textsubscript{1\textsubscript{i}} or par\textsubscript{2\textsubscript{i}}) or x\textsubscript{i} = \$}\\
            \text{sum$\$$(pr\textsubscript{$i$})+ rand(pr\textsubscript{$i$})} + 0.1, & \text{: $\forall x\textsubscript{i}$ = y\textsubscript{i} and (x\textsubscript{i} $\neq$ par\textsubscript{1\textsubscript{i}} or par\textsubscript{2\textsubscript{i}}) or x\textsubscript{i} = \$}\\
	\infty & \text{: else}
            \end{array}\right\}
      \]

\end{cmr}
\noindent {\large \textbf{Or-tree-based Search Instance:}}

\noindent We define our initial search state, $s_0$, as follows:

\noindent \centerline{$s_0$ = pr = $\langle X_1, \dots, X_n\rangle$ such that, $\forall X_i$ $\in$ pr, $X_i$ = \$}

\noindent However, $s_0$ will occasionally be equal to a partial assignment, \textit{partassign}. This will be stipulated more formally in the search control for our Set-based Search.

\noindent Our goal state, $G_{\lor}$, is equivalent with the definition of the notion, ``pr is solved", as seen above.\\
\newpage

\noindent \textbf{Set-Based Search Model}

\begin{cmr}
\noindent We define a set of facts, $F$, to be a set of candidate solutions produced by an Or-tree-based Search as described above.
As mentioned in the problem overview, we will assume that our initial set $F$ will be of size pop_init.
\end{cmr}

\noindent Before formally defining $F$, we define $D_i$, the domain of any element in an individual, $F_i$, to be the set: \{0, $\dots$, $j$\} where $j+1$ = $\vert$Slots$\vert$.

\noindent \centerline{$F$ = \{$\langle X_1, \dots, X_n\rangle$\textsubscript{$1$}, $\dots$, $\langle X_1, \dots, X_n\rangle$\textsubscript{$k$} $\vert$ $X_i \in D_i$, $1 \le i \le n$, $k = \text{pop_init}$\}}

\begin{comment}
\noindent Before defining Ext, we will first define an alternative Search Control for the Or-tree-based Search used for generating candidate solutions.

\noindent Search Control\textsubscript{Alt}:

\noindent Our O\textsubscript{Tree}, once again, will obviously begin with a single node, (pr, ?); and its expansion will be governed by the recursive relation, Erw\textsubscript{$\lor$}.

\noindent If both of the selected parents, $A$ and $B$, have the same first element, then pr will be initialized with that element's value as its first element, followed by \$'s. Otherwise pr will be initialized with all \$'s, as before.

\noindent For each subsequent element of pr, if $A$ and $B$ agree upon its value, control will select that value --- generating a single new successor node with a pr vector that reflects the addition of that shared value. Otherwise, if they disagree, Altern will be applied.

\noindent After each application of Altern, the search control will perform a constraint analysis on each new successor node of O\textsubscript{Tree} using \textbf{Constr\textsuperscript{*}}.
Nodes where \textbf{Constr\textsuperscript{*}} evaluates to false will be pruned out of O\textsubscript{Tree} prior to leaf selection.

\noindent Leaf selection will occur as in the original search control, using the same f\textsubscript{leaf} function and randomized selection from among the set of leafs of equal proximity to a solution.

\begin{cmr}
\noindent Once again, after f\textsubscript{leaf} values have been calculated for each node, if there is a solved node then the search is finished and the solved problem instance is returned as output.

\noindent Otherwise, all unsolvable nodes will be pruned and the control will then select a random leaf as mentioned above and resume the expansion of O\textsubscript{Tree}.
\end{cmr}
\end{comment}

\noindent Now we will define the set of extension rules, Ext:
\begin{enumerate} [topsep=0pt, itemsep=0pt, leftmargin=*]
\item Crossover:
	\begin{enumerate}[leftmargin=*]
	\item $A$ = select($F$), $B$ = select($F - A$). (We will define select($F$) in our Search Process).
	\item Now that we have selected two parent facts, we will execute our Or-tree-based Search using the Crossover Search Control.
	\item The resulting solution produced by this search will then be added to the population.
	\end{enumerate} 
\item Reduce:
	\begin{enumerate}
	\item A fact is removed from the set of facts.
	\item A $\rightarrow$ B $\vert$ B = $\emptyset$
	\end{enumerate}
\item Populate:
	\begin{enumerate}
	\item A new fact is generated by running an Or-tree-based Search using the initial search control. Where the starting state of the tree is either as defined in our Or-tree-based Search 		instance or \textit{partassign} if \textit{partassign} was given as input.
	\item  A $\rightarrow$ B $\vert$ A = $\emptyset$
	\end{enumerate}
\end{enumerate}

\noindent \textbf{Set-Based Search Process}

\noindent Here we define the function, select($F$), which will be used in Ext to pick individuals out of the population in order to perform the crossover operation on them.

\noindent select: $F$ $\Rightarrow$ ($F_i$) is an implementation of the roulette-wheel selection algorithm.\\\\
select($F$) \{
\begin{algorithmic}[\textfloatsep = 0pt]
    \STATE sum = 0
    \FOR {$A_i$ in $F$}
    	\STATE $A_i$.\textbf{Eval} = \textbf{Eval}($A_i$)
	\STATE sum ++ $A_i$.\textbf{Eval}
    \ENDFOR
    \FOR {$A_i$ in $F$}
    	\STATE $A_i$.\textbf{Eval}_norm = $A_i$.\textbf{Eval} / sum
    \ENDFOR
    \STATE sort($F$, $A_i$.\textbf{Eval}_norm)
    \FOR {$A_i$ in $F$}
    	\FOR {$A_j$ in $F$ and $A_j$.index $<$ $A_i$.index}
    		\STATE $A_i$.ACNF += $A_j$.\textbf{Eval}_norm
    	\ENDFOR
    \ENDFOR
    \STATE rand r = randFloatBetween(0, 1)
    \STATE selected = NULL
    \STATE index = 0
    \WHILE {true}
    	\STATE selected = $F_{\text{index}}$
    	\IF {$F_{\text{(index + 1)}}$.ACNF $\geq$ r}
    		\STATE return selected
    	\ENDIF
	\STATE index ++ 1
    \ENDWHILE \\ \}
\end{algorithmic}

\noindent We also define a function pop(F) which evaluates the size of the current population, where F is the current set of facts.

    \[
        \text{pop(F)} = \left\{\begin{array}{ll}
            -1 & \text{: $\vert$F$\vert$ $<$ pop_init}\\
            1 & \text{: $\vert$F$\vert$ $>$ pop_max}\\
            0 & \text{: else}
            \end{array}\right\}
      \]

\begin{comment}
\noindent Here we define the function, reduce($F$), which will be used in Ext to reduce the size a generation that has become too large. The removal of individuals from the population will be performed quasi-randomly via the select($F$) function, in order to avoid implementing an elitist GA.\\\\
reduce($F$) \{
\begin{algorithmic}[\textfloatsep = 0pt]
    \IF {$\vert F \vert$ \% 2 == 0}
    	\STATE target_size = $\dfrac{\vert F \vert}{2}$
    \ELSE
    	\STATE target_size = $\dfrac{\vert F \vert + 1}{2}$
    \ENDIF
    \STATE $i$ = 0
    \WHILE {$i <$ target_size}
    	\STATE individual = select($F$)
	\STATE $F$ = $F$ - individual
	\STATE $i$ ++ 1
    \ENDWHILE \\ \}
\end{algorithmic}
\end{comment}

\noindent Search Control:

\noindent The search control for our Set-based Search will be responsible for producing the initial set, $F$, tracking the amount of time elapsed, and counting the number of generations that our GA has modelled. The first thing our control will do is start a timer.

\noindent In order to decide which transition to apply to our set of facts we pick the transition that minimizes f\textsubscript{Wert}.

    \[
        \text{f\textsubscript{Wert}(A, B, e)} = \left\{\begin{array}{ll}
            \text{-2(pop(F))} & \text{: A = $\emptyset$}\\
            \text{2(pop(F))} & \text{: B = $\emptyset$}\\
            -1 & \text{: else}
            \end{array}\right\}
      \]

\begin{comment}
\noindent Next, in order to produce $F$, the control will execute the following algorithm:

\noindent produce($F$) \{
\begin{algorithmic}[\textfloatsep = 0pt]
    \STATE $i$ = 0
    \WHILE {$i <$ pop_init}
    	\IF {\textit{partassign} $\in$ input}
		\STATE individual = Or-tree-based Search execution with $s_0$ = \textit{partassign}
	\ELSE
		\STATE individual = Or-tree-based Search execution with $s_0$ as originally defined in our Or-tree-based Search Instance
	\ENDIF
	\STATE $F$ = $F$ + individual
	\STATE $i$ ++ 1
    \ENDWHILE \\ \}
\end{algorithmic}
\end{comment}

\noindent We have already defined a method to select the two parents for the crossover extension and we don't need to pick a fact for the populate extension to operate on, however we do need to control which fact the reduce extension rule is applied to. We do this by using \textbf{Eval} to evaluate how well each fact follows the soft constraint. The fact with the maximum \textbf{Eval} score is used for the reduction.

\noindent f\textsubscript{select} (\{A\textsubscript{1} $\rightarrow$ B\textsubscript{1}, $\dots$, A\textsubscript{m} $\rightarrow$ B\textsubscript{m}\}, e) = A\textsubscript{i} $\rightarrow$ B\textsubscript{i}

\noindent where A\textsubscript{i} $\neq$ $\emptyset$ and \textbf{Eval}(A\textsubscript{i}) $<$ \textbf{Eval}(A\textsubscript{j}), i $\neq$ j, 1 $\geq$ i, j $\geq$ m or i $<$ j

\noindent Every time after the crossover rule is applied, the generation counter will increase by 1. If after any application of an extension, the time limit is up or the generation counter reaches the predetermined maximum threshold, the search control will halt the GA. At that point, the most fit individual (according to the \textbf{Eval} function) in the current population will be returned as the final, optimized solution to the assignment problem.

\noindent \textbf{Set-Based Search Instance}

\noindent s\textsubscript{0} = Start state for the search instance --- composed of pop_init candidate solutions.\\
G\textsubscript{Set}(s) = Yes, if and only if enough generations have been reached or enough time has elapsed.\\\\

\noindent That concludes our description of a Set-based Search solution to the assignment problem.

\newpage

\centerline{{\Large Search Paradigm II --- And-Tree-Based Search}}
\section*{And-tree Search Model}

For the model, Prob is defined as a vector of length |Courses + Labs|, whose elements consist of the indices of slots from Slots, or the unassigned symbol, \$. The ordering of vector will be the same as the original ordering of Courses + Labs. Therefore, a Prob vector can be read sequentially as: Course/Lab at position $i$, having value $j$, has been assigned time slot $s_{j}$, where $s_{j}$ is the member $s$ of the set Slots at the $j^{th}$ index of Slots. As such, the definition of Prob is equivalent with the notion of a partial assignment, $\textit{partassgin}$.

$D_{i}$, defined as the domain of any element in a problem instance, pr, to be the set: {0,...,$j$} where $j$ + 1 = |Slots|. With that, Prob is defined as follows:

\begin{center}
{Prob = <$C_{1}$slot,...,$C_{n}$slot,...,$L_{11}$slot,...,$L_{1k_{1}}$slot,...,$L_{n1}$slot,..,$L_{nk_{n}}$slot> \\ such that $C_{i}$slot, $L_{ik_{i}}$slot $\in D_{i} \cup \big\{\$\big\}$}
\end{center}

Which can be abstracted into the form:

\begin{center}
{Prob = <$X_{1}$,...,$X_{n}$> such that $X_{i} \in D_{i} \cup \big\{\$\big\}$ }
\end{center}
The divide relation, Div, defined as:

\begin{center}
{Div = $\big\{((X_{1},...,X_{i},...,X_{n}),(X_{1},...,d_{i1},...,X_{in}),...,(X_{1},...d_{il},...,X_{n}))$  | $ X_{i} = \$, 1 \le i \le n, |D_{i}| = l, D_{i} = \big\{d_{i},...,d_{il}$\big\}\big\}}
\end{center}

"pr is solved" is defined as follows:

\begin{center}
{pr = ($X_{1},...,X_{n}$) and $\forall$$i$ such that $1 \le i \le n$, $X_{i} \neq \$$, and pr is not unsolvable.}
\end{center}

"pr is unsolvable" is defined as follows:

\begin{center}
{pr = ($X_{1},...,X_{n}$) and there is a constraint $C_{i} = R_{i}(X_{1},...,X_{k}$) such that $\exists$$X_{ij} \in $pr with a value unequal to \$ and ($X_{1},...,X_{k}$) do not satisfy $R_{i}$.}
\end{center}

Since we have access to  \textbf{Constr$^{\ast}$}, derived from the provided function, \textbf{Constr}, we can allow  \textbf{Constr$^{\ast}$} to perform the work of assessing whether any particular problem instance, pr, is compliant with the problem;s hard constraints.

{\centering 
\textbf{And - Tree Based Search}
\bigskip

Search Process
\par}

\bigskip
\bigskip

Having defined the search model we are now ready to define the Search Process and Control.

\bigskip

The $And_{tree}$ will begin with a single node, $s_0 = (pr, ?)$, and its expansion will be defined by the recursive relation $Erw_{and}$. Each iteration will use $Div$ to expand the tree and create new nodes. After each $Div$, $F_{bound}$ prunes leaves that are irrelevant for our search via a branch and bound operation, using a $beta$ value. After this, $F_{leaf}$  evaluates all the leaves, and calculates a number that will correspond to the state. The search control will prioritize applying $Div$ to the lowest value leaves first. The search control will choose the left most leaf in the case that $F_{leaf}$ provides a tie between multiple leaves.
\bigskip
\bigskip

$F_{leaf}$ uses an additional helper function, $F_{penalty}$, which evaluates a penalty score of an assignment, based on the soft and hard constraints. For partial assignments, $F_{penalty}$ $^*$ is used, which uses $Eval^*$ and $Constr^*$ instead. $F_{penalty}$ is used by both $F_{leaf}$ and $F_{bound}$.

\bigskip
$F_{penalty}$ : $\{pr_1, ...$, $pr_n \} $  $ \to \mathbb{R} $    where 1 $\leq i \leq n$


 
 \[
          \text{F\textsubscript{penalty}} = \left\{\begin{array}{ll}
            \infinity &	 \text{: if Constr}($pr_i$)= \text{false} \\
            Eval(pr_i) & 	 \text{: else}\\
            
            \end{array}\right\}
      \]




 
\bigskip
Using this we can define $F_{leaf}$ : 
\bigskip

$F_{leaf}$ : $\{pr_1, ...$, $pr_n \} $  $ \to \mathbb{R} $  

$F_{leaf} = (F_{penalty}(\{pr_1, ...$, $pr_n \}))$

\bigskip

$F_{leaf}$ applies $F_{penalty}$ in order to calculate a numeric value for the search control.

\bigskip
\bigskip


$F_{bound}$ is used by the search control to keep the tree size within reason. It uses $\beta$ pruning to remove leaves that fail to beat the best found solution so far.
We can define $F_{bound}$ using $F_{bound}$. Once again we can use $F_{bound}$ $^*$ to evaluate partial assignments using $F_{penalty}$ $^*$.

\bigskip
$F_{bound}$ : $\{pr_1, ...$, $pr_n \} $  $ \to pr_i $    where 1 $\leq i\leq n$

 \[
          \text{F\textsubscript{bound}} = \left\{\begin{array}{ll}
            \beta = \infinity $: if $pr_i \in s_0 \\
           \beta = F_{penalty} $: else$\\
            
            \end{array}\right\}
      \]
      
\bigskip

$\beta _{best}$ is the smallest $\beta$ value that $F_{bound}$ or  $F_{bound}$ $^*$ has evaluated to.


if $\beta _{pr_i}$ $\leq \beta _{best}$ then $\beta_ {best} = \beta _{pr_i } $


if $\beta _{pr_i}$  $> \beta _{best}$ then  $pr_i = null$, pruning the leaf from the tree.


\bigskip
\bigskip

As there is is only one $Div$ relation, $F_{trans}$ is not used. 

There is no backtracking in this search control.

\bigskip
\bigskip
\bigskip
A state is marked as $solved$ when:

\bigskip 

$\forall X \in Prob, X_i \cup \{ \$ \} = \o $ where $X_i$ is some $X$ in $Prob$.

It is the state where each course and lab has a slot assigned to it. The state will take on the form $(pr, solved)$.
\bigskip
\bigskip
\bigskip

The search control operation operates in the following order:

\bigskip
1. Apply $F_{leaf}$ to the tree.

2. Apply $Div$ to the tree, prioritizing the branch with the lowest $F_{leaf}$ value. In case of a tie, the left most branch is used. $Div$ is applied to all unsolved branches $(pr, ?)$. It is at this point that all lower leaves are checked for $(pr, solved)$.

3. Apply $F_{bound}$ to the tree, pruning the leaves that are out of bounds if needed.

\bigskip
\bigskip
\bigskip
\bigskip
 
Search Instance:

As before the initial search state is $s_0$:

\bigskip

$s_0 = pr = <X_1, ..., X_n> $ such that $\forall X_i \in pr, X_i = \$ $ 

\bigskip

The goal state is $G_{and}$ is reached when all branches are marked with $(pr, solved)$.

\noindent \textbf{And-Tree-Based Search Process}\\\\
P\textsubscript{$\land$} = ( A\textsubscript{$\land$}, K\textsubscript{$\land$}):\\
\indent A\textsubscript{$\land$} = the Search Model\\
\indent K\textsubscript{$\land$} = the Search Control\\\\
\noindent K\textsubscript{$\land$} uses two functions: f\textsubscript{Leaf}, and f\textsubscript{Trans}, which compare all leaves of the tree representing the state and select one, and select one of the transitions available to the selected leaf, respectively.\\

\noindent \textbf{And-Tree-Based Search Instance}\\\\
Ins\textsubscript{$\land$} = (s\textsubscript{0}, G\textsubscript{$\land$}):\\
\indent s\textsubscript{0} = (pr, ?)\\
\indent G\textsubscript{$\land$}(s) = yes, if and only if:
\begin{enumerate}[leftmargin=25mm,topsep=0pt]
\item[$\bullet$] s = (pr', yes) or,
\item[$\bullet$] s = (pr', ?, b\textsubscript{1}, $\ldots$, b\textsubscript{n}), G\textsubscript{$\land$}(b\textsubscript{1}) = $\ldots$ = G\textsubscript{$\land$}(b\textsubscript{n}) = yes and the solutions to b\textsubscript{1}, $\ldots$, b\textsubscript{n} are compatible with each other. Or,
\item[$\bullet$] there is no possible transition that has not already been attempted and analyzed
\end{enumerate}

\end{document}