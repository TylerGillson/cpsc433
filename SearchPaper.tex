\documentclass[11pt, oneside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
    \geometry{
     a4paper,
     top=20mm,
     }
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{underscore}
\usepackage{caption}
\usepackage{algorithmic}
\usepackage{enumitem}		
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}
\setlength{\parskip}{1em}
\setlength{\parindent}{4em}
\usepackage{graphicx}				% Use pdf, png, jpg, or epsÂ§ with pdflatex; use eps in DVI mode
								% TeX will automatically convert eps --> pdf in pdflatex		
\usepackage{amssymb}

\newenvironment{cmr}{\fontfamily{cmr}\selectfont}{\par}

\setlength{\parskip}{1em}
\setlength{\parindent}{4em}

\title{\vspace{40mm}CPSC 433 --- Assignment I}
\author{
	Daniel Gillson\\
	David Keizer\\
	Ethan Higgs\\
	Zheng Liang\\
	Zibin Mei}
\date{October 20\textsuperscript{th} 2017}

\newpage
\begin{document}
\maketitle
\break

\centerline{{\Large Search Paradigm I --- Set-Based Search}}

\noindent {\\ \large \textbf{Solution Overview}}\\\\
\begin{cmr}
\indent Our approach to solving the problem within the context of set-based search will rely mainly on the use of a genetic algorithm.
We will obtain an initial, randomly generated population for our GA via an Or-tree-based Search that will provide candidate solutions to the problem's
hard constraints. In this first stage of our solution, we remove the problem's soft constraints, thereby re-formulating it as a constraint satisfaction problem (CSP).

\indent Once we have obtained an initial population of some size, pop_init, we will consider its individuals to be facts in a Set-based Search.
We will also define a constant, pop_max, as an upper bound on the size of any later generation.
The set-based search will use our genetic algorithm's cross-over function, and a reduce function as its extension rules.
The reduce function will remove individuals with large f\textsubscript{Wert} values from the population until the population has been halved, should it ever reach a size of pop_max.
We will use the provided \textbf{Eval} function to compute f\textsubscript{Wert}. Furthermore, there will be no need for an f\textsubscript{Select} function in our set based search, as
transitions to each successive generation will be determined by our GA's selection function.
The start state will be our initial set of randomly generated facts and our goal state will be: ``Whichever occurs first: 50 generations have been modelled, or an hour has elapsed".

\indent In our GA, we will use f\textsubscript{Wert} = \textbf{Eval} as a fitness function, \textbf{Cons} and \textbf{Cons\textsuperscript{*}} for constraint-checking, and roulette-wheel selection as a selection method.
\textbf{Cons\textsuperscript{*}} is a variant of \textbf{Cons} used to evaluate the constraint-compliance of partial solutions, which we assume can be derived from the provided \textbf{Cons} function.
\end{cmr}

\noindent {\large \textbf{Or-tree-based Search Model}}

\noindent We define Prob as a vector of length $\vert$Courses + Labs$\vert$, whose elements consist of the indices of slots from Slots, or the unassigned symbol, \$. The vector's ordering will preserve the original ordering of Courses + Labs. Therefore, a Prob vector can be read sequentially as: Course/Lab at position $i$, having value $j$, has been assigned time slot $s_j$, where $s_j$ is the member $s$ of the set Slots at the $j$\textsuperscript{th} index of that set. As such, our definition of Prob is equivalent with the notion of a partial assignment, \textit{partassign}.

\noindent Before formally defining Prob, we define $D_i$, the domain of any element in a problem instance, pr, to be the set: \{0, $\dots$, $j$\} where $j+1$ = $\vert$Slots$\vert$.

\noindent \centerline{Prob =  $\langle C_1 \text{slot}, \dots, C_n \text{slot}, \dots, L_{11} \text{slot}, \dots, L_{1{k_1}} \text{slot}, \dots, L_{n1} \text{slot}, \dots, L_{n{k_n}} \text{slot}\rangle$}\\
\centerline{such that $C_i \text{slot}$, $L_{i{k_i}} \text{slot} \in D_i \cup \{\$\}$}

\noindent Which can be abstracted into the form:

\noindent \centerline{Prob = $\langle X_1, \dots, X_n\rangle$ such that $X_i \in D_i \cup \{\$\}$}

\noindent We define our alternatives relation, Altern, as follows:

\noindent \centerline{Altern = $\{((X_1, \dots, X_i, \dots, X_n), (X_1, \dots, d_{i1}, \dots, X_{in}), \dots, (X_1, \dots, d_{i\ell}, \dots, X_n))$ $\vert$ $X_i$ = $\$$,}\\
\centerline{$1 \le i \le n$, $\vert D_i \vert = \ell$, $D_i = \{d_i, \dots, d_{i\ell}\}\}$}

\noindent We define the notion, ``pr is solved" as follows:

\noindent \centerline{pr = $(X_1, \dots, X_n)$ and $\forall i$ such that $1 \le i \le n$, $X_i$ $\neq$ $\$$, and pr is not unsolvable.}

\noindent We define the notion, ``pr is unsolvable" as follows:

\noindent \centerline{pr = $(X_1, \dots, X_n)$ and there is a constraint $C_i = R_i(X_1, \dots, X_k)$}\\
\centerline{such that $\exists X_{ij}$ $\in$ pr with a value unequal to $\$$ and $(X_1, \dots, X_k)$ do not satisfy $R_i$.}

\noindent Since we have access to \textbf{Constr\textsuperscript{*}}, derived from the provided function, \textbf{Constr}, we can allow \textbf{Constr\textsuperscript{*}} to perform the work of assessing whether any particular problem instance, pr, is compliant with the problem's hard constraints.

\noindent {\large \textbf{Or-tree-based Search Process}}

\begin{cmr}
\noindent Search Control:

\noindent Our O\textsubscript{Tree} will obviously begin with a single node, (pr, ?). Its expansion will be governed by the recursive relation, Erw\textsubscript{$\lor$}.
After each application of Altern, the search control will perform a constraint analysis on each new successor node of O\textsubscript{Tree} using \textbf{Constr\textsuperscript{*}}.
Nodes where \textbf{Constr\textsuperscript{*}} evaluates to false will be pruned out of O\textsubscript{Tree} prior to leaf selection.

\noindent The search control will pick a random leaf from among the minimal f\textsubscript{leaf} values.

\noindent In order to define f\textsubscript{leaf}, we must first define a function, sum\$: pr $\Rightarrow$ $\mathbb{Z}$. Which, given some pr, returns the number of \$ entries within it. 
\end{cmr}

\noindent f\textsubscript{leaf}: \{pr\textsubscript{1}, $\dots$, pr\textsubscript{$n$}\} $\Rightarrow$ pr\textsubscript{$i$}\\
    \[
        \text{f\textsubscript{leaf}} = \left\{\begin{array}{ll}
            -1, & \text{if (pr\textsubscript{$i$}, yes)}\\
            0, & \text{if (pr\textsubscript{$i$}, no)}\\
            \text{sum$\$$(pr\textsubscript{$i$})}, & \text{if (pr\textsubscript{$i$}, ?)}
            \end{array}\right\}
      \]

\begin{cmr}
\noindent After f\textsubscript{leaf} values have been calculated for each node, if there is a solved node then the search is finished and the solved problem instance is returned as output.

\noindent Otherwise, all unsolvable nodes will be pruned, and a random integer, $r$, will be generated such that $1 \le r \le n$, where n is equal to the number of remaining new successor nodes generated by Altern.
Control will then select the $r$\textsuperscript{th} node and resume the expansion of O\textsubscript{Tree}.
\end{cmr}

\noindent {\large \textbf{Or-tree-based Search Instance:}}

\noindent We define our initial search state, $s_0$, as follows:

\noindent \centerline{$s_0$ = pr = $\langle X_1, \dots, X_n\rangle$ such that, $\forall X_i$ $\in$ pr, $X_i$ = \$}

\noindent However, $s_0$ will occasionally be equal to a partial assignment, \textit{partassign}. This will be stipulated more formally in the search control for our Set-based Search.

\noindent Our goal state, $G_{\lor}$, is equivalent with the definition of the notion, ``pr is solved", as seen above.\\
\newpage

\noindent \textbf{Set-Based Search Model}

\begin{cmr}
\noindent We define a set of facts, $F$, to be a set of candidate solutions produced by an Or-tree-based Search as described above.
As mentioned in the problem overview, we will assume that our initial set $F$ will be of size pop_init.
\end{cmr}

\noindent Before formally defining $F$, we define $D_i$, the domain of any element in an individual, $F_i$, to be the set: \{0, $\dots$, $j$\} where $j+1$ = $\vert$Slots$\vert$.

\noindent \centerline{$F$ = \{$\langle X_1, \dots, X_n\rangle$\textsubscript{$1$}, $\dots$, $\langle X_1, \dots, X_n\rangle$\textsubscript{$k$} $\vert$ $X_i \in D_i$, $1 \le i \le n$, $k = \text{pop_init}$\}}

\noindent Before defining Ext, we will first define an alternative Search Control for the Or-tree-based Search used for generating candidate solutions.

\noindent Search Control\textsubscript{Alt}:

\noindent Our O\textsubscript{Tree}, once again, will obviously begin with a single node, (pr, ?); and its expansion will be governed by the recursive relation, Erw\textsubscript{$\lor$}.

\noindent If both of the selected parents, $A$ and $B$, have the same first element, then pr will be initialized with that element's value as its first element, followed by \$'s. Otherwise pr will be initialized with all \$'s, as before.

\noindent For each subsequent element of pr, if $A$ and $B$ agree upon its value, control will select that value --- generating a single new successor node with a pr vector that reflects the addition of that shared value. Otherwise, if they disagree, Altern will be applied.

\noindent After each application of Altern, the search control will perform a constraint analysis on each new successor node of O\textsubscript{Tree} using \textbf{Constr\textsuperscript{*}}.
Nodes where \textbf{Constr\textsuperscript{*}} evaluates to false will be pruned out of O\textsubscript{Tree} prior to leaf selection.

\noindent Leaf selection will occur as in the original search control, using the same f\textsubscript{leaf} function and randomized selection from among the set of leafs of equal proximity to a solution.

\begin{cmr}
\noindent Once again, after f\textsubscript{leaf} values have been calculated for each node, if there is a solved node then the search is finished and the solved problem instance is returned as output.

\noindent Otherwise, all unsolvable nodes will be pruned and the control will then select a random leaf as mentioned above and resume the expansion of O\textsubscript{Tree}.
\end{cmr}

\noindent Now we will define the set of extension rules, Ext:
\begin{enumerate} [topsep=0pt, itemsep=0pt, leftmargin=*]
\item Cross-Over/Mutation:
	\begin{enumerate}[leftmargin=*]
	\item $A$ = select($F$), $B$ = select($F - A$). (We will define select($F$) in our Search Process).
	\item Now that we have selected two parent facts, we will execute our Or-tree-based Search using Search Control\textsubscript{Alt}.
	\item The resulting solution produced by this search will then be added to the population.
	\end{enumerate} 
\item Reduce:
	\begin{enumerate}
	\item If the size of the current generation equals pop_max, execute reduce($F$). (We will define reduce($F$) in our Search Process).
	\end{enumerate}
\end{enumerate}

\noindent \textbf{Set-Based Search Process}

\noindent Here we define the function, select($F$), which will be used in Ext to pick individuals out of the population in order to perform the cross-over/mutation operation on them.

\noindent select: $F$ $\Rightarrow$ ($F_i$) is an implementation of the roulette-wheel selection algorithm.\\\\
select($F$) \{
\begin{algorithmic}[\textfloatsep = 0pt]
    \STATE sum = 0
    \FOR {$A_i$ in $F$}
    	\STATE $A_i$.\textbf{Eval} = \textbf{Eval}($A_i$)
	\STATE sum ++ $A_i$.\textbf{Eval}
    \ENDFOR
    \FOR {$A_i$ in $F$}
    	\STATE $A_i$.\textbf{Eval}_norm = $A_i$.\textbf{Eval} / sum
    \ENDFOR
    \STATE sort($F$, $A_i$.\textbf{Eval}_norm)
    \FOR {$A_i$ in $F$}
    	\FOR {$A_j$ in $F$ and $A_j$.index $<$ $A_i$.index}
    		\STATE $A_i$.ACNF += $A_j$.\textbf{Eval}_norm
    	\ENDFOR
    \ENDFOR
    \STATE rand r = randFloatBetween(0, 1)
    \STATE selected = NULL
    \STATE index = 0
    \WHILE {true}
    	\STATE selected = $F_{\text{index}}$
    	\IF {$F_{\text{(index + 1)}}$.ACNF $\geq$ r}
    		\STATE return selected
    	\ENDIF
	\STATE index ++ 1
    \ENDWHILE \\ \}
\end{algorithmic}

\noindent Here we define the function, reduce($F$), which will be used in Ext to reduce the size a generation that has become too large. The removal of individuals from the population will be performed quasi-randomly via the select($F$) function, in order to avoid implementing an elitist GA.\\\\
reduce($F$) \{
\begin{algorithmic}[\textfloatsep = 0pt]
    \IF {$\vert F \vert$ \% 2 == 0}
    	\STATE target_size = $\dfrac{\vert F \vert}{2}$
    \ELSE
    	\STATE target_size = $\dfrac{\vert F \vert + 1}{2}$
    \ENDIF
    \STATE $i$ = 0
    \WHILE {$i <$ target_size}
    	\STATE individual = select($F$)
	\STATE $F$ = $F$ - individual
	\STATE $i$ ++ 1
    \ENDWHILE \\ \}
\end{algorithmic}

\noindent Search Control:

\noindent The search control for our Set-based Search will be responsible for producing the initial set, $F$, tracking the amount of time elapsed, and counting the number of generations that our GA has modelled. The first thing our control will do is start a timer.

\noindent Next, in order to produce $F$, the control will execute the following algorithm:

\noindent produce($F$) \{
\begin{algorithmic}[\textfloatsep = 0pt]
    \STATE $i$ = 0
    \WHILE {$i <$ pop_init}
    	\IF {\textit{partassign} $\in$ input}
		\STATE individual = Or-tree-based Search execution with $s_0$ = \textit{partassign}
	\ELSE
		\STATE individual = Or-tree-based Search execution with $s_0$ as originally defined in our Or-tree-based Search Instance
	\ENDIF
	\STATE $F$ = $F$ + individual
	\STATE $i$ ++ 1
    \ENDWHILE \\ \}
\end{algorithmic}

\noindent Once $F$ has been produced, a generation counter will be instantiated with the value ``1". Following that, the search control will simply allow our GA to begin evolving its initial population. If at any point the timer reaches one hour or the generation counter reaches 50, the search control will halt the GA. At that point, the most fit individual (according to the \textbf{Eval} function) in the current population will be returned as the final, optimized solution to the assignment problem.

\noindent \textbf{Set-Based Search Instance}

\noindent s\textsubscript{0} = Start state for the search instance --- composed of pop_init candidate solutions.\\
G\textsubscript{Set}(s) = Yes, if and only if 50 generations have been modelled, or one hour has elapsed.\\\\

\noindent That concludes our description of a Set-based Search solution to the assignment problem.

\newpage

\centerline{{\Large Search Paradigm II --- And-Tree-Based Search}}
\noindent \textbf{\\And-Tree-Based Search Model}\\\\
A\textsubscript{$\land$} = (S\textsubscript{$\land$}, T\textsubscript{$\land$}):\\
\indent Prob = set of problem descriptions\\
\indent Div $\subseteq$ Prob\textsuperscript{+} = division relation for generating sub-problems out of problem instances\\
\indent S\textsubscript{$\land$} $\subseteq$ A\textsubscript{Tree}\\
\indent T\textsubscript{$\land$} = \{(s\textsubscript{1}, s\textsubscript{2}) $\vert$ s\textsubscript{1}, s\textsubscript{2} $\in$ S\textsubscript{$\land$} and Erw\textsubscript{$\land$}(s\textsubscript{1}, s\textsubscript{2})\}\\\\
Where A\textsubscript{tree} is recursively defined by:\\
\indent (pr, sol) $\in$ A\textsubscript{Tree} for pr $\in$ Prob, sol $\in$ \{yes, ?\}\\
\indent (pr, sol, b\textsubscript{1}, $\ldots$, b\textsubscript{n}) $\in$ A\textsubscript{Tree} for pr $\in$ Prob, sol $\in$ \{yes, ?\}, b\textsubscript{1}, $\ldots$, b\textsubscript{n} $\in$ A\textsubscript{Tree}

\noindent Erw\textsubscript{$\land$} is a relation on A\textsubscript{Tree} defined by:

\indent Erw\textsubscript{$\land$}((pr, ?)) = (pr,yes) if pr is solved\\
\indent Erw\textsubscript{$\land$}((pr, ?)) = (pr, ?, (pr\textsubscript{1}, ?), $\ldots$, (pr\textsubscript{n}, ?)) if Div(pr, pr\textsubscript{1}, $\ldots$, pr\textsubscript{n}) holds\\
\indent Erw\textsubscript{$\land$}((pr, ?, b\textsubscript{1}, $\ldots$, b\textsubscript{n})) = (pr, ?, b\textsubscript{1}', $\ldots$, b\textsubscript{n}'), if for an i:\\
\centerline{Erw\textsubscript{$\land$}(b\textsubscript{i}, b\textsubscript{i}') and b\textsubscript{j} = b\textsubscript{j}' for i $\neq$ j}

\noindent Erw\textsuperscript{*}\textsubscript{$\land$} is ignored here, as back-tracking is unnecessary when considering the problem at hand.\\

\noindent \textbf{And-Tree-Based Search Process}\\\\
P\textsubscript{$\land$} = ( A\textsubscript{$\land$}, K\textsubscript{$\land$}):\\
\indent A\textsubscript{$\land$} = the Search Model\\
\indent K\textsubscript{$\land$} = the Search Control\\\\
\noindent K\textsubscript{$\land$} uses two functions: f\textsubscript{Leaf}, and f\textsubscript{Trans}, which compare all leaves of the tree representing the state and select one, and select one of the transitions available to the selected leaf, respectively.\\

\noindent \textbf{And-Tree-Based Search Instance}\\\\
Ins\textsubscript{$\land$} = (s\textsubscript{0}, G\textsubscript{$\land$}):\\
\indent s\textsubscript{0} = (pr, ?)\\
\indent G\textsubscript{$\land$}(s) = yes, if and only if:
\begin{enumerate}[leftmargin=25mm,topsep=0pt]
\item[$\bullet$] s = (pr', yes) or,
\item[$\bullet$] s = (pr', ?, b\textsubscript{1}, $\ldots$, b\textsubscript{n}), G\textsubscript{$\land$}(b\textsubscript{1}) = $\ldots$ = G\textsubscript{$\land$}(b\textsubscript{n}) = yes and the solutions to b\textsubscript{1}, $\ldots$, b\textsubscript{n} are compatible with each other. Or,
\item[$\bullet$] there is no possible transition that has not already been attempted and analyzed
\end{enumerate}

\noindent \textbf{\\We need to define:}
\begin{itemize}[topsep=0pt]
\item Prob
\item Div
\item f\textsubscript{Leaf}
\item f\textsubscript{Trans}
\end{itemize}

\end{document}